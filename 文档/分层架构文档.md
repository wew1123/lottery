# 抽奖系统分层架构详解

## 一、整体架构概述

本项目采用经典的分层架构设计，从下到上依次为：基础设施层、数据访问层、业务逻辑层、接口层。这种设计使得各层职责清晰，便于维护和扩展。

```
┌─────────────────┐
│   接口层 (API)   │
├─────────────────┤
│  业务逻辑层      │
├─────────────────┤
│  数据访问层      │
├─────────────────┤
│  基础设施层      │
└─────────────────┘
```

## 二、各层详细解析

### 1. 接口层 (API Layer)

**目录位置**：`internal/handlers/`

**职责**：
- 处理HTTP请求和响应
- 参数验证和错误处理
- 路由分发
- 请求上下文管理

**核心文件**：
- `lotteryv1.go`、`lotteryv2.go`、`lotteryv3.go`：不同版本的抽奖接口
- `prizeadd.go`：奖品添加接口
- `login.go`：登录接口
- `handler.go`：基础Handler定义

**设计特点**：
- 每个接口版本对应独立的Handler结构体
- 统一的请求参数绑定和响应格式
- 基于Gin框架实现路由和中间件
- 错误码统一管理

**示例代码**：
```go
type LotteryHandlerV1 struct {
    req  *params.LotteryReq
    resp *HttpResponse
    
    limitService   service.LimitService
    lotteryService service.LotteryService
    resultService  service.ResultService
}

func LotteryV1(c *gin.Context) {
    h := LotteryHandlerV1{
        req:            &params.LotteryReq{},
        resp:           &HttpResponse{},
        limitService:   service.GetLimitService(),
        lotteryService: service.GetLotteryService(),
        resultService:  service.GetResultService(),
    }
    // ... 处理逻辑
}
```

### 2. 业务逻辑层 (Service Layer)

**目录位置**：`internal/service/`

**职责**：
- 实现核心业务逻辑
- 协调各数据访问层操作
- 事务管理
- 业务规则验证

**核心文件**：
- `lottery.go`：抽奖核心逻辑
- `limit.go`：抽奖次数限制
- `result.go`：抽奖结果处理
- `user.go`：用户相关业务
- `admin.go`：管理员操作

**设计特点**：
- 面向接口编程，每个业务模块定义独立接口
- 单例模式实现服务实例
- 依赖注入，便于测试和扩展
- 业务逻辑与数据访问解耦

**示例代码**：
```go
type LotteryService interface {
    GetPrize(ctx context.Context, prizeCode int) (*LotteryPrize, error)
    GetAllUsefulPrizes(ctx context.Context) ([]*LotteryPrize, error)
    GiveOutPrize(ctx context.Context, prizeID int) (bool, error)
}

var lotteryServiceImpl *lotteryService

func NewLotteryService() {
    lotteryServiceImpl = &lotteryService{
        prizeReop:     repo.NewPrizeRepo(),
        couponReop:    repo.NewCouponRepo(),
        blackUserRepo: repo.NewBlackUserRepo(),
        blackIpRepo:   repo.NewBlackIpRepo(),
    }
}
```

### 3. 数据访问层 (Repository Layer)

**目录位置**：`internal/repo/`

**职责**：
- 数据库CRUD操作
- 缓存读写
- 数据转换
- 事务实现

**核心文件**：
- `prize.go`：奖品数据访问
- `user.go`：用户数据访问
- `result.go`：抽奖结果数据访问
- `blackuser.go`：黑名单用户数据访问
- `blackip.go`：黑名单IP数据访问

**设计特点**：
- 每个实体对应独立的Repository
- 封装数据库操作细节
- 支持缓存和数据库双重读写
- 统一的错误处理

**示例代码**：
```go
type PrizeReop struct {
}

func NewPrizeRepo() *PrizeReop {
    return &PrizeReop{}
}

func (p *PrizeReop) GetAllUsefulPrizeList(db *gorm.DB) ([]*model.Prize, error) {
    var list []*model.Prize
    err := db.Where("sys_status = ?", constant.StatusValid).
        Where("begin_time <= ?", time.Now().Unix()).
        Where("end_time >= ?", time.Now().Unix()).
        Order("display_order desc, id asc").
        Find(&list).Error
    return list, err
}
```

### 4. 基础设施层 (Infrastructure Layer)

**目录位置**：`internal/pkg/`

**职责**：
- 提供通用技术能力
- 封装第三方依赖
- 实现横切关注点

**核心模块**：

#### 4.1 中间件 (middlewares)
- `cache/`：Redis缓存实现
- `gormcli/`：数据库连接和ORM
- `lock/`：分布式锁
- `log/`：日志系统

#### 4.2 常量定义 (constant)
- `const.go`：通用常量
- `error.go`：错误码定义
- `prize.go`：奖品相关常量

#### 4.3 定时任务 (task)
- `ip.go`：IP抽奖次数重置
- `user.go`：用户抽奖次数重置
- `prize.go`：奖品发放计划

#### 4.4 工具函数 (utils)
- 加密解密
- 时间处理
- 字符串操作

**设计特点**：
- 独立可复用的技术组件
- 配置化管理
- 统一的接口和实现
- 便于替换和升级

**示例代码**：
```go
// 分布式锁实现
func NewRedisLock(key string, opts ...Option) *RedisLock {
    lock := &RedisLock{
        key:          key,
        expire:       5,
        watchDogMode: false,
    }
    for _, opt := range opts {
        opt(lock)
    }
    return lock
}

func (r *RedisLock) Lock(ctx context.Context) error {
    // ... 锁实现逻辑
}
```

### 5. 数据模型层 (Model Layer)

**目录位置**：`internal/model/`

**职责**：
- 定义数据库表对应的结构体
- 字段验证和约束
- 数据转换

**核心文件**：
- `model.go`：所有数据模型定义

**设计特点**：
- 与数据库表结构一一对应
- 使用GORM标签定义字段属性
- 支持软删除、时间戳等特性

**示例代码**：
```go
type Prize struct {
    Id            uint      `gorm:"primaryKey"`
    Title         string    `gorm:"size:255;not null;default:''"`
    PrizeNum      int       `gorm:"not null;default:-1"`
    LeftNum       int       `gorm:"not null;default:0"`
    PrizeCode     string    `gorm:"size:50;not null;default:''"`
    PrizeTime     uint      `gorm:"not null;default:0"`
    Img           string    `gorm:"size:255;not null;default:''"`
    DisplayOrder  uint      `gorm:"not null;default:0"`
    PrizeType     uint      `gorm:"not null;default:0"`
    PrizeProfile  string    `gorm:"size:255;not null;default:''"`
    BeginTime     uint      `gorm:"not null;default:0"`
    EndTime       uint      `gorm:"not null;default:0"`
    PrizePlan     string    `gorm:"type:mediumtext"`
    PrizeBegin    uint      `gorm:"not null;default:0"`
    PrizeEnd      uint      `gorm:"not null;default:0"`
    SysStatus     uint8     `gorm:"not null;default:1"`
    SysCreated    time.Time `gorm:"autoCreateTime"`
    SysUpdated    time.Time `gorm:"autoUpdateTime"`
    SysIp         string    `gorm:"size:50;not null;default:''"`
}
```

### 6. 配置层 (Config Layer)

**目录位置**：`configs/`

**职责**：
- 管理系统配置
- 配置加载和解析
- 配置验证

**核心文件**：
- `config.go`：配置加载逻辑
- `config.yml`：配置文件

**设计特点**：
- 分层配置（应用、数据库、日志、Redis）
- 环境变量支持
- 配置验证和默认值

**示例代码**：
```go
type Config struct {
    AppConfig   AppConfig   `mapstructure:"app"`
    DbConfig    DbConfig    `mapstructure:"db"`
    LogConfig   LogConfig   `mapstructure:"log"`
    RedisConfig RedisConfig `mapstructure:"redis"`
}

func InitConfig() *Config {
    // ... 配置加载逻辑
}
```

### 7. 路由层 (Router Layer)

**目录位置**：`router/`

**职责**：
- 定义API路由
- 中间件配置
- 路由分组

**核心文件**：
- `router.go`：路由定义
- `gin.go`：Gin框架初始化

**设计特点**：
- 版本化路由管理
- 中间件按需配置
- 路由分组清晰

**示例代码**：
```go
func InitRouterAndServe() {
    r := gin.Default()
    
    // 中间件配置
    r.Use(gin.Logger())
    r.Use(gin.Recovery())
    
    // 路由定义
    v1 := r.Group("/api/v1")
    {
        v1.POST("/lottery", handlers.LotteryV1)
        v1.POST("/prize/add", handlers.PrizeAdd)
    }
    
    // 启动服务
    r.Run(fmt.Sprintf(":%d", configs.GetConfig().AppConfig.Port))
}
```

## 三、分层架构优势

1. **职责清晰**：各层职责明确，便于团队协作
2. **可维护性**：修改某一层不影响其他层
3. **可扩展性**：新功能可以方便地添加到对应层
4. **可测试性**：各层独立，便于单元测试
5. **技术隔离**：底层技术变更不影响上层业务

## 四、代码规范与最佳实践

1. **命名规范**：
   - 包名使用小写字母
   - 结构体名使用驼峰式
   - 接口名以"er"结尾
   - 常量名使用大写字母加下划线

2. **错误处理**：
   - 统一错误码管理
   - 错误信息清晰明确
   - 错误日志包含上下文信息

3. **依赖管理**：
   - 依赖注入
   - 面向接口编程
   - 减少循环依赖

4. **性能优化**：
   - 缓存策略
   - 数据库连接池
   - 异步处理

5. **安全规范**：
   - 输入验证
   - 防止SQL注入
   - XSS防护
   - 敏感信息加密

## 五、总结

本项目的分层架构设计使得代码结构清晰，易于维护和扩展。各层之间通过接口进行通信，降低了耦合度，提高了代码的复用性。同时，项目遵循了Go语言的最佳实践，使用了成熟的第三方库和设计模式，确保了系统的稳定性和性能。